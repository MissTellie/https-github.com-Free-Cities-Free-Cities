#!/usr/bin/env python3

'''
Application for procedural content adaption
Contains a very poor man's implementation of spline mesh warping.

This application parses SVG path data of an outfit sample aligned to a body part.
The outfit is then replicated for other shapes of the same body part.

Example data is geared towards generating a strap outfit for boobs and torso
for all sizes of boobs and all shapes of torsos based on a single outfit for
boobs of size 2 and a hourglass torso respectively.

Limitations:
* handles paths only
* only svg.path Line and CubicBezier are tested
* only the aforementioned examples are tested
'''

from svg.path import parse_path
import copy
import lxml.etree as etree
import sys

REFERENCE_PATH_SAMPLES = 50

mode = sys.argv[1]

# TODO: make these configurable
if ('boobs' == mode):
  xpath_shape = './svg:g[@id="Chest"]/svg:g[@id="Boob_%s"]/svg:g[starts-with(@id, "Boob_Large") or starts-with(@id, "Areola")]/svg:path[@style="fill:#f6e0e8" or @style="fill:#d76b93"]/@d'
  xpath_outfit_container = './svg:g[@id="Chest_Outfit"]'
  xpath_outfit = './svg:g[@id="Boob_%s_straps"]'
  target_ids = "0,1,2,3,4,5,6,7".split(",")
  reference_id = "2"
elif ('torso' == mode):
  xpath_shape = './svg:g[@id="Torso"]/svg:g[@id="Torso_%s"]/svg:path[@style="fill:#f6e0e8"]/@d'
  xpath_outfit_container = './svg:g[@id="Torso_Outfit"]'
  xpath_outfit = './svg:g[@id="Torso_%s_straps"]'
  target_ids = "Unnatural,Hourglass,Normal".split(",")
  reference_id = "Hourglass"
else:
  raise RuntimeError("Please specify a mode of operation.")

'''
Problems with originally supplied "vector source.svg":
* Inconsistent layer names
* Generated by Adobe Illustrator, groups are no Inkscape layers by default
* Inkscape uses layer labels instead of layer ids
'''
root = etree.parse('vector source.svg') # TODO: do not hardcode input file path
ns = {'svg' : 'http://www.w3.org/2000/svg'}

def get_points(xpath_shape, index):
  '''
  This funciton extracts reference paths by the given xpath selector.
  Each path is used to sample a fixed number of points.
  '''
  print('Getting shape data for variant "%s"...'%(index))
  paths_data = root.xpath(xpath_shape%(index),namespaces=ns)
  points = []
  path_length = None
  for path_data in paths_data:
    p = parse_path(path_data)
    points += [
      p.point(1.0/float(REFERENCE_PATH_SAMPLES)*i) 
      for i in range(REFERENCE_PATH_SAMPLES)
    ]
  if (not points):
    raise RuntimeError(
      'No paths for reference points found by selector "%s".'%(xpath_shape%(index))
    )
  return points

def point_movement(point, reference_points, target_points):
  '''
  For a given point, finds the nearest point in the reference path.
  Gives distance vector from the nearest reference point to the
  respective target reference point.
  '''
  distances = [abs(point-reference_point) for reference_point in reference_points]
  min_ref_dist_idx = min(enumerate(distances), key=lambda x:x[1])[0]
  movement = target_points[min_ref_dist_idx] - reference_points[min_ref_dist_idx]
  return movement

reference_points = get_points(xpath_shape, reference_id)
container = root.xpath(xpath_outfit_container,namespaces=ns)
if (len(container) != 1):
  raise RuntimeError('Outfit container selector "%s" does not yield exactly one layer.'%(xpath_outfit_container))
container = container[0]
outfit_source = container.xpath(xpath_outfit%(reference_id),namespaces=ns)
if (len(outfit_source) != 1):
  raise RuntimeError('Outfit source selector "%s" does not yield exactly one outfit layer in container selected by "%s".'%(xpath_outfit%(reference_id), xpath_outfit_container))
outfit_source = outfit_source[0]

for target_id in target_ids:
  outfit = copy.deepcopy(outfit_source)
  paths = outfit.xpath('./svg:path',namespaces=ns)
  if target_id == reference_id:
    continue
  layerid = outfit.get('id').replace('_%s_'%(reference_id),'_%s_'%(target_id))
  outfit.set('id', layerid)
  outfit.set(etree.QName('http://www.inkscape.org/namespaces/inkscape', 'label'), layerid) # for the Inkscape-users
  target_points = get_points(xpath_shape, target_id)
  if (len(reference_points) != len(target_points)):
    raise RuntimeError(
      ('Different amounts of sampled points in reference "%s" and target "%s" paths. '+
      'Selector "%s" probably matches different number of paths in the two layers.')%
      (reference_id, target_id, xpath_shape)
    )
  for path in paths:
    path_data = path.get("d")
    p = parse_path(path_data)
    for segment in p:
      original_distance = abs(segment.end-segment.start)
      start_movement = point_movement(segment.start, reference_points, target_points)
      segment.start += start_movement
      end_movement = point_movement(segment.end, reference_points, target_points)
      segment.end += end_movement
      distance = abs(segment.end-segment.start)
      try:
        # enhance position of CubicBezier control points
        # amplification is relative to the distance gained by movement
        segment.control1 += start_movement
        segment.control1 += (segment.control1-segment.start)*(distance/original_distance-1.0)
        segment.control2 += end_movement
        segment.control2 += (segment.control2-segment.end)*(distance/original_distance-1.0)
      except AttributeError as ae:
        # segment is not a CubicBezier
        pass
    path.set("d", p.d())
  container.append(outfit)

svg = etree.tostring(root, pretty_print=True)
with open('replicated.svg', 'wb') as f: # TODO: do not hardcode output file path
  f.write('<?xml version="1.0" encoding="UTF-8" standalone="no"?>\n'.encode("utf-8"))
  f.write(svg)
